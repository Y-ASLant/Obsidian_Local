# Linux 主要特性

> [!NOTE]
> Linux 是一个基于文件的操作系统
> 
> 操作系统需要和硬件进行交互, 对应 Linux 来说这些硬件都是文件，比如: 操作系统会将硬盘, 鼠标, 键盘, 显示屏等抽象成一个设备文件来进行管理。
> 
> Linux 操作系统是一种自由软件，是免费的，并且公开源代码。
> 
> 可以同时登陆多个用户，并且每个用户可以同时运行多个应用程序。
> 
> 提供了友好的图形用户界面, 操作简单，易于快速上手。
> 
> 支持多平台（这里指的是基于不同 CPU 架构的平台，比如国产 Linux 使用的龙芯等）。



![[../ASLant_Files/2024-06-18-13-06-25.png]]

# Linux目录结构

在linux中根目录的子目录结构相对是固定的(名字固定), 不同的目录功能是也是固定的

> [!tree] 目录结构
> bin: binary, 二进制文件目录, 存储了可执行程序, 今天要将的命令对应的可执行程序都在这个目录中
> 
> sbin: super binary, root用户使用的一些二进制可执行程序
> 
> etc: 配置文件目录, 系统的或者用户自己安装的应用程序的配置文件都存储在这个目录中
> 
> lib: library, 存储了一些动态库和静态库，给系统或者安装的软件使用
> 
> media: 挂载目录, 挂载外部设备，比如: 光驱, 扫描仪
> 
> mnt: 临时挂载目录, 比如我们可以将U盘临时挂载到这个目录下
> 
> proc: 内存使用的一个映射目录, 给操作系统使用的
> 
> tmp: 临时目录, 存放临时数据, 重启电脑数据就被自动删除了
> 
> boot: 存储了开机相关的设置
> 
> home: 存储了普通用户的家目录，家目录名和用户名相同
> 
> root: root用户的家目录
> 
> dev: device , 设备目录, Linux中一切皆文件, 所有的硬件会抽象成文件存储起来，比如：键盘， 鼠标
> 
> lost+found: 一般时候是空的, 电脑异常关闭/崩溃时用来存储这些无家可归的文件, 用于用户系统恢复
> 
> opt: 第三方软件的安装目录
> 
> var: 存储了系统使用的一些经常会发生变化的文件， 比如：日志文件
> 
> usr: unix system resource, 系统的资源目录
> 
> /usr/bin: 可执行的二进制应用程序
> 
> /usr/games: 游戏目录
> 
> /usr/include: 包含的标准头文件目录
> 
> /usr/local: 和opt目录作用相同, 安装第三方软件

对于用户自己的文件, 一般都是存放到自己的家目录中, 也就是` /home/用户名`里边, 通过指定的相应的路径就可以找到这个文件了。关于路径的指定的有两种方式：`相对路径`和`绝对路径`。

# 相对路径

> [!NOTE]
> 相对路径：相对路径就是相对于当前文件的路径。在Linux中有两个表示路径的特殊符号:
> 
> `./`：代表目前所在的目录，也可以使用 `.`表示。
> 
> `../`：代表当前目录的上一层目录，也可以使用 `..`表示。

以上边的目录为例, 从当前root家目录 /root, 进入到 onepiece目录使用相对路径

```shell

```
<font color="#4bacc6">接下来研究一下相对路径的优缺点:</font>

- **优点**: 简洁, 目录相对较短, 书写方便
- 缺点: 变更工作目录之后, 使用相同的相对路径就找不到原来的文件了
# 绝对路径

> [!NOTE]
> 绝对路径：从系统磁盘起始节点开始描述的路径。
> 
> Linux：起始节点为<font color="#00b050">根目录</font>，比如：/mnt/h/WSL/Kali/ASLant/
> 
> Windows: 起始节点为<font color="#ff0000">某个磁盘的盘符</font>，比如：H:\WSL\Kali\ASLant

以上边的目录为例, 从当前root家目录 /root, 进入到 onepiece目录使用绝对路径
```sh
┌──(root㉿YASLant)-[/]
└─# cd /mnt/h/WSL/Kali/ASLant/
```
<font color="#4bacc6">接下来研究一下绝对路径的优缺点:</font>

- **优点**: 在操作系统的任意位置都可以通过绝对路径访问到对应的文件
- 缺点: 字符串较长, 书写起来比较麻烦, 看起来也不够简洁

# 3. 命令解析器
在Linux中需要通过终端执行对应的命令来完成某些操作, 那么这些命令是如何被执行的呢?

这些命令都是通过命令解析器解析完成并执行的, 如果用户在终端输入是正确的内部指令, 命令解析器就执行这个命令, 如果不是正确的指令, 则提示命令无法解析。

下图是Windows是命令行窗口，平台虽然不同但是命令解析器的工作原理是相同的。



3.1 工作原理
命令解析器在Linux操作系统中就是一个进程(运行的应用程序), 它的名字叫做bash通常我们更习惯将其称之为shell (即: sh)。他们之间的渊源是这样的，在Unix操作系统诞生之后一个叫伯恩(Bourne )的人为其编写了命令解析器取名为shell, Linux操作系统诞生之后伯恩再次改写了shell (sh), 将其称之为bash (Bourne Again SHell), bash 就是 sh 的增强版本。

在Linux操作系统中默认使用的命令解析器是 bash, 当然也同样支持使用sh。当用户打开一个终端窗口，并输入相关指令， 按回车键， 这时候命令解析器就开始工作了， 具体步骤如下：

在Linux中有一个叫做PATH的环境变量, 里边存储了一些系统目录 (windows也有, 叫 Path)

SHELL
1
2
3
# 通过 echo 命令可以查看环境变量 PATH 中的值, 在shell中变量名前加 $ 就是取值
[root@VM-8-14-centos ~]# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
命令解析器需要依次搜索 PATH中的各个目录, 检查这些目录中是否有用户输入的指令

如果找到了, 执行该目录下的可执行程序, 用户输入的命令就被执行完毕了

如果没有找到, 继续搜索其他目录, 最后还是没有找到, 会提示命令找不到, 因此无法被执行

SHELL
1
2
[root@VM-8-14-centos ~]# asdjflksd
-bash: asdjflksd: command not found


作者: 苏丙榅
链接: https://subingwen.cn/linux/version-path/
来源: 爱编程的大丙
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。













































