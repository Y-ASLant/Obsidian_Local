# Linux 主要特性

> [!NOTE]
> Linux 是一个基于文件的操作系统
> 
> 操作系统需要和硬件进行交互, 对应 Linux 来说这些硬件都是文件，比如: 操作系统会将硬盘, 鼠标, 键盘, 显示屏等抽象成一个设备文件来进行管理。
> 
> Linux 操作系统是一种自由软件，是免费的，并且公开源代码。
> 
> 可以同时登陆多个用户，并且每个用户可以同时运行多个应用程序。
> 
> 提供了友好的图形用户界面, 操作简单，易于快速上手。
> 
> 支持多平台（这里指的是基于不同 CPU 架构的平台，比如国产 Linux 使用的龙芯等）。

![[../ASLant_Files/2024-06-18-13-06-25.png|600]]

# Linux目录结构

> [!NOTE]
> 与 Windows 下的文件组织结构不同，Linux 不使用磁盘分区符号来访问文件系统，而是将整个文件系统表示成树状的结构，Linux 系统每增加一个文件系统都会将其加入到这个树中。
> 操作系统文件结构的开始，只有一个单独的顶级目录结构，叫做 `根目录`。所有一切都从“根”开始，用“/”代表，并且延伸到子目录。Linux 则通过“挂接”的方式把所有分区都放置在“根”下各个目录里。一个 Linux 系统的文件结构如下图所示。
> 

![[../ASLant_Files/2024-06-19-18-12-03.png]]

在linux中根目录的子目录结构相对是固定的(名字固定), 不同的目录功能是也是固定的

> [!tree] 目录结构
> bin: binary, 二进制文件目录, 存储了可执行程序, 今天要将的命令对应的可执行程序都在这个目录中
> 
> sbin: super binary, root用户使用的一些二进制可执行程序
> 
> etc: 配置文件目录, 系统的或者用户自己安装的应用程序的配置文件都存储在这个目录中
> 
> lib: library, 存储了一些动态库和静态库，给系统或者安装的软件使用
> 
> media: 挂载目录, 挂载外部设备，比如: 光驱, 扫描仪
> 
> mnt: 临时挂载目录, 比如我们可以将U盘临时挂载到这个目录下
> 
> proc: 内存使用的一个映射目录, 给操作系统使用的
> 
> tmp: 临时目录, 存放临时数据, 重启电脑数据就被自动删除了
> 
> boot: 存储了开机相关的设置
> 
> home: 存储了普通用户的家目录，家目录名和用户名相同
> 
> root: root用户的家目录
> 
> dev: device , 设备目录, Linux中一切皆文件, 所有的硬件会抽象成文件存储起来，比如：键盘， 鼠标
> 
> lost+found: 一般时候是空的, 电脑异常关闭/崩溃时用来存储这些无家可归的文件, 用于用户系统恢复
> 
> opt: 第三方软件的安装目录
> 
> var: 存储了系统使用的一些经常会发生变化的文件， 比如：日志文件
> 
> usr: unix system resource, 系统的资源目录
> 
> /usr/bin: 可执行的二进制应用程序
> 
> /usr/games: 游戏目录
> 
> /usr/include: 包含的标准头文件目录
> 
> /usr/local: 和opt目录作用相同, 安装第三方软件

> [!NOTE]- 以下是对这些目录的解释：
> 
> - **/bin**：  
>     bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。
>     
> - **/boot：**  
>     这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。
>     
> - **/dev ：**  
>     dev 是 Device (设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。
>     
> - **/etc：**  
>     etc 是 Etcetera (等等) 的缩写, 这个目录用来存放所有的系统管理所需要的配置文件和子目录。
>     
> - **/home**：  
>     用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。
>     
> - **/lib**：  
>     lib 是 Library (库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。
>     
> - **/lost+found**：  
>     这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。
>     
> - **/media**：  
>     linux 系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。
>     
> - **/mnt**：  
>     系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。
>     
> - **/opt**：  
>     opt 是 optional (可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个 ORACLE 数据库则就可以放到这个目录下。默认是空的。
>     
> - **/proc**：  
>     proc 是 Processes (进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。  
>     这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的 ping 命令，使别人无法 ping 你的机器：
>     
>     echo 1 > /proc/sys/net/ipv 4/icmp_echo_ignore_all
>     
> - **/root**：  
>     该目录为系统管理员，也称作超级权限者的用户主目录。
>     
> - **/sbin**：  
>     s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。
>     
> - **/selinux**：  
>      这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放 selinux 相关的文件的。
>     
> - **/srv**：  
>      该目录存放一些服务启动之后需要提取的数据。
>     
> - **/sys**：
>     
>     这是 Linux 2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。
>     
>     sysfs 文件系统集成了下面 3 种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。
>     
>     该文件系统是内核设备树的一个直观反映。
>     
>     当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。
>     
> - **/tmp**：  
>     tmp 是 temporary (临时) 的缩写这个目录是用来存放一些临时文件的。
>     
> - **/usr**：  
>      usr 是 unix shared resources (共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。
>     
> - **/usr/bin：**  
>     系统用户使用的应用程序。
>     
> - **/usr/sbin：**  
>     超级用户使用的比较高级的管理程序和系统守护程序。
>     
> - **/usr/src：**  
>     内核源代码默认的放置目录。
>     
> - **/var**：  
>     var 是 variable (变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。
>     
> - **/run**：  
>     是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。
>     

对于用户自己的文件, 一般都是存放到自己的家目录中, 也就是 ` /home/用户名` 里边, 通过指定的相应的路径就可以找到这个文件了。关于路径的指定的有两种方式：`相对路径` 和 `绝对路径`。

> [!NOTE]
> 在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。
> **/etc**： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。
> **/bin, /sbin, /usr/bin, /usr/sbin**: 这是系统预设的执行文件的放置目录，比如 **ls** 就是在 **/bin/ls** 目录下的。
> 值得提出的是 **/bin**、**/usr/bin** 是给系统用户使用的指令（除 root 外的通用用户），而/sbin, /usr/sbin 则是给 root 使用的指令。
> **/var**： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 /var/log 目录下，另外 mail 的预设放置也是在这里。

# 相对路径

> [!NOTE]
> 相对路径：相对路径就是相对于当前文件的路径。在Linux中有两个表示路径的特殊符号:
> 
> `./`：代表目前所在的目录，也可以使用 `.`表示。
> 
> `../`：代表当前目录的上一层目录，也可以使用 `..`表示。

以上边的目录为例, 从当前root家目录 /root, 进入到 onepiece目录使用相对路径

```shell

```
<font color="#4bacc6">接下来研究一下相对路径的优缺点:</font>

- **优点**: 简洁, 目录相对较短, 书写方便
- 缺点: 变更工作目录之后, 使用相同的相对路径就找不到原来的文件了
# 绝对路径

> [!NOTE]
> 绝对路径：从系统磁盘起始节点开始描述的路径。
> 
> Linux：起始节点为<font color="#00b050">根目录</font>，比如：/mnt/h/WSL/Kali/ASLant/
> 
> Windows: 起始节点为<font color="#ff0000">某个磁盘的盘符</font>，比如：H:\WSL\Kali\ASLant

以上边的目录为例, 从当前root家目录 /root, 进入到 onepiece目录使用绝对路径
```sh
┌──(root㉿YASLant)-[/]
└─# cd /mnt/h/WSL/Kali/ASLant/
```
<font color="#4bacc6">接下来研究一下绝对路径的优缺点:</font>

- **优点**: 在操作系统的任意位置都可以通过绝对路径访问到对应的文件
- 缺点: 字符串较长, 书写起来比较麻烦, 看起来也不够简洁

# 命令解析器

> [!NOTE]
> 在Linux中需要通过终端执行对应的命令来完成某些操作, 那么这些命令是如何被执行的呢?
> 这些命令都是通过命令解析器解析完成并执行的, 如果用户在终端输入是正确的内部指令, 命令解析器就执行这个命令, 如果不是正确的指令, 则提示命令无法解析。
> 下图是Windows是命令行窗口，平台虽然不同但是命令解析器的工作原理是相同的。
![[../ASLant_Files/2024-06-18-14-55-42.png|458]]

## 工作原理

> [!error]
> 命令解析器在Linux操作系统中就是一个进程(运行的应用程序), 它的名字叫做bash通常我们更习惯将其称之为shell (即: sh)。他们之间的渊源是这样的，在Unix操作系统诞生之后一个叫伯恩(Bourne )的人为其编写了命令解析器取名为shell, Linux操作系统诞生之后伯恩再次改写了shell (sh), 将其称之为bash (Bourne Again SHell), bash 就是 sh 的增强版本。
> 
> 在Linux操作系统中默认使用的命令解析器是 bash, 当然也同样支持使用sh。当用户打开一个终端窗口，并输入相关指令， 按回车键， 这时候命令解析器就开始工作了， 具体步骤如下：

- 在Linux中有一个叫做 `PATH` 的环境变量, 里边存储了一些系统目录 (`Windows也有, 叫 Path`)
 ```sh
 # 通过 echo 命令可以查看环境变量 PATH 中的值, 在shell中变量名前加 $ 就是取值
┌──(root㉿YASLant)-[~]
└─# echo $PATH
 /usr/local/bin:/usr/bin:/bin
 ```

- 命令解析器需要依次搜索`PATH`中的各个目录, 检查这些目录中是否有用户输入的指令
	- 如果找到了, 执行该目录下的可执行程序, 用户输入的命令就被执行完毕了
	- 如果没有找到, 继续搜索其他目录, 最后还是没有找到, 会提示命令找不到, 因此无法被执行

```sh
┌──(root㉿YASLant)-[~]
└─# asdasd
-bash: asdasd: command not found
```































