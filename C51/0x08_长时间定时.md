## 题目要求
---

> 用定时器T0的中断实现长时间定时

<br/>   

## 仿真图	
---

![[../ASLant_Files/bb87184ed982c38e432bf6e86a5fee9a_MD5.jpg]]	

> [仿真源文件](/123pan/?d=N7orVv-OpMV3.html)		


<br/>   

## 源代码   
---

```c
#include <reg51.h>     //  包含51单片机寄存器定义的头文件
sbit D1 = P2 ^ 0;      // 将D1位定义为P2.0引脚
unsigned char Countor; // 设置全局变量，储存定时器T0中断次数
/**************************************************************
函数功能：主函数
**************************************************************/
void main(void)
{
    D1 = 0;
    EA = 1;                      // 开总中断
    ET0 = 1;                     // 定时器T0中断允许
    TMOD = 0x01;                 // 使用定时器T0的模式2
    TH0 = (65536 - 46083) / 256; // 定时器T0的高8位赋初值
    TL0 = (65536 - 46083) % 256; // 定时器T0的高8位赋初值
    TR0 = 1;                     // 启动定时器T0
    Countor = 0;                 // 从0开始累计中断次数
    while (1)                    // 无限循环等待中断
        ;
}
/**************************************************************
函数功能：定时器T0的中断服务程序
**************************************************************/
void Time0(void) interrupt 1 using 0 // “interrupt”声明函数为中断服务函数
                                     // 其后的1为定时器T0的中断编号；0表示使用第0组工作寄存器 共8组
{
    Countor++;         // 中断次数自加1
    if (Countor == 50) // 若累计满20次，即计时满1s  50次为2.5s
    {
        D1 = ~D1;    // 按位取反操作，将P2.0引脚输出电平取反
        Countor = 0; // 将Countor清0，重新从0开始计数
    }
    TH0 = (65536 - 46083) / 256; // 定时器T0的高8位重新赋初值
    TL0 = (65536 - 46083) % 256; // 定时器T0的高8位重新赋初值
}
```

## 效果预览
----

![[../ASLant_Files/f327daa46135c0ff9f37e332ff87979c_MD5.gif]]
