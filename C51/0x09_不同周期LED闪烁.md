## 题目要求
---

> 用定时器T1中断控制两个LED以不同周期闪烁   


<br/>   

## 仿真图	
---

![[ASLant_Images/82f1f29088e27571ce96d237d4aecb82_MD5.jpg]]	

> [仿真源文件](/123pan/?d=N7orVv-RpMV3.html)		


<br/>   

## 源代码   
---

```c
#include <reg51.h>		//  包含51单片机寄存器定义的头文件
sbit D1 = P2 ^ 0;		// 将D1位定义为P2.0引脚
sbit D2 = P2 ^ 1;		// 将D2位定义为P2.1引脚
unsigned char Countor1; // 设置全局变量，储存定时器T1中断次数
unsigned char Countor2; // 设置全局变量，储存定时器T1中断次数
/**************************************************************
函数功能：主函数
**************************************************************/
void main(void)
{
	EA = 1;						 // 开总中断
	ET1 = 1;					 // 定时器T1中断允许
	TMOD = 0x10;				 // 使用定时器T1的模式1
	TH1 = (65536 - 46083) / 256; // 定时器T1的高8位赋初值
	TL1 = (65536 - 46083) % 256; // 定时器T1的高8位赋初值
	TR1 = 1;					 // 启动定时器T1
	Countor1 = 0;				 // 从0开始累计中断次数
	Countor2 = 0;				 // 从0开始累计中断次数
	while (1)					 // 无限循环等待中断
		;
}
/**************************************************************
函数功能：定时器T1的中断服务程序
**************************************************************/
void Time1(void) interrupt 3 using 0 // “interrupt”声明函数为中断服务函数
									 // 其后的3为定时器T1的中断编号；0表示使用第0组工作寄存器
{
	Countor1++;		   // Countor1自加1
	Countor2++;		   // Countor2自加1
	if (Countor1 == 2) // 若累计满2次，即计时满100ms
	{
		D1 = ~D1;	  // 按位取反操作，将P2.0引脚输出电平取反
		Countor1 = 0; // 将Countor1清0，重新从0开始计数
	}
	if (Countor2 == 8) // 若累计满8次，即计时满400ms
	{
		D2 = ~D2;	  // 按位取反操作，将P2.1引脚输出电平取反
		Countor2 = 0; // 将Countor1清0，重新从0开始计数
	}
	TH1 = (65536 - 46083) / 256; // 定时器T1的高8位重新赋初值
	TL1 = (65536 - 46083) % 256; // 定时器T1的高8位重新赋初值
}

```

## 效果预览
----

![[ASLant_Images/ba931cd64dde4c6f543fe5c34d2ed84f_MD5.gif]]  
